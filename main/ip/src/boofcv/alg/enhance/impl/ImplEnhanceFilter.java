/*
 * Copyright (c) 2011-2013, Peter Abeles. All Rights Reserved.
 *
 * This file is part of BoofCV (http://boofcv.org).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package boofcv.alg.enhance.impl;

import boofcv.struct.convolve.Kernel2D_F32;
import boofcv.struct.convolve.Kernel2D_I32;
import boofcv.struct.image.ImageFloat32;
import boofcv.struct.image.ImageUInt8;

/**
 * <p>
 * Filter based functions for image enhancement.
 * </p>
 *
 * <p>
 * NOTE: Do not modify.  Automatically generated by {@link GenerateImplEnhanceFilter}.
 * </p>
 *
 * @author Peter Abeles
 */
public class ImplEnhanceFilter {

	public static Kernel2D_I32 kernelEnhance4_I32 = new Kernel2D_I32(3, new int[]{0,-1,0,-1,5,-1,0,-1,0});
	public static Kernel2D_F32 kernelEnhance4_F32 = new Kernel2D_F32(3, 0,-1,0,-1,5,-1,0,-1,0);
	public static Kernel2D_I32 kernelEnhance8_I32 = new Kernel2D_I32(3, new int[]{-1,-1,-1,-1,9,-1,-1,-1,-1});
	public static Kernel2D_F32 kernelEnhance8_F32 = new Kernel2D_F32(3, -1,-1,-1,-1,9,-1,-1,-1,-1);

	public static void sharpenInner4( ImageUInt8 input , ImageUInt8 output , int minValue , int maxValue ) {
		for( int y = 1; y < input.height-1; y++ ) {
			int indexIn = input.startIndex + y*input.stride + 1;
			int indexOut = output.startIndex + y*output.stride + 1;

			for( int x = 1; x < input.width-1; x++ , indexIn++,indexOut++) {

				int a = 5*(input.data[indexIn] & 0xFF) - (
						(input.data[indexIn-1] & 0xFF)+(input.data[indexIn+1] & 0xFF) +
								(input.data[indexIn-input.stride] & 0xFF) + (input.data[indexIn+input.stride] & 0xFF));

				if( a > maxValue )
					a = maxValue;
				else if( a < minValue )
					a = minValue;

				output.data[indexOut] = (byte)a;
			}
		}
	}

	public static void sharpenInner4( ImageFloat32 input , ImageFloat32 output , float minValue , float maxValue ) {
		for( int y = 1; y < input.height-1; y++ ) {
			int indexIn = input.startIndex + y*input.stride + 1;
			int indexOut = output.startIndex + y*output.stride + 1;

			for( int x = 1; x < input.width-1; x++ , indexIn++,indexOut++) {

				float a = 5*(input.data[indexIn] ) - (
						(input.data[indexIn-1] )+(input.data[indexIn+1] ) +
								(input.data[indexIn-input.stride] ) + (input.data[indexIn+input.stride] ));

				if( a > maxValue )
					a = maxValue;
				else if( a < minValue )
					a = minValue;

				output.data[indexOut] = a;
			}
		}
	}

	public static void sharpenInner8( ImageUInt8 input , ImageUInt8 output , int minValue , int maxValue ) {
for( int y = 1; y < input.height-1; y++ ) {
			int indexIn = input.startIndex + y*input.stride + 1;
			int indexOut = output.startIndex + y*output.stride + 1;

			for( int x = 1; x < input.width-1; x++ , indexIn++,indexOut++) {

				int a11 = input.data[indexIn-input.stride-1] & 0xFF;
				int a12 = input.data[indexIn-input.stride] & 0xFF;
				int a13 = input.data[indexIn-input.stride+1] & 0xFF;
				int a21 = input.data[indexIn-1] & 0xFF;
				int a22 = input.data[indexIn] & 0xFF;
				int a23 = input.data[indexIn+1] & 0xFF;
				int a31 = input.data[indexIn+input.stride-1] & 0xFF;
				int a32 = input.data[indexIn+input.stride] & 0xFF;
				int a33 = input.data[indexIn+input.stride+1] & 0xFF;
				
				int result = 9*a22 - (a11+a12+a13+a21+a23+a31+a32+a33);

				if( result > maxValue )
					result = maxValue;
				else if( result < minValue )
					result = minValue;

				output.data[indexOut] = (byte)result;
			}
		}
	}

	public static void sharpenInner8( ImageFloat32 input , ImageFloat32 output , float minValue , float maxValue ) {
for( int y = 1; y < input.height-1; y++ ) {
			int indexIn = input.startIndex + y*input.stride + 1;
			int indexOut = output.startIndex + y*output.stride + 1;

			for( int x = 1; x < input.width-1; x++ , indexIn++,indexOut++) {

				float a11 = input.data[indexIn-input.stride-1] ;
				float a12 = input.data[indexIn-input.stride] ;
				float a13 = input.data[indexIn-input.stride+1] ;
				float a21 = input.data[indexIn-1] ;
				float a22 = input.data[indexIn] ;
				float a23 = input.data[indexIn+1] ;
				float a31 = input.data[indexIn+input.stride-1] ;
				float a32 = input.data[indexIn+input.stride] ;
				float a33 = input.data[indexIn+input.stride+1] ;
				
				float result = 9*a22 - (a11+a12+a13+a21+a23+a31+a32+a33);

				if( result > maxValue )
					result = maxValue;
				else if( result < minValue )
					result = minValue;

				output.data[indexOut] = result;
			}
		}
	}


}
